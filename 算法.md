# 算法

+ 查找算法
  1. 顺序查找
  2. 二分查找
  3. 插值查找
  4. 斐波那契查找
  5. 树表查找
  6. 分块查找
  7. 哈希查找
+ 排序算法
  1. 冒泡排序
  2. 快速排序
  3. 简单插入排序
  4. 希尔排序
  5. 简单选择排序
  6. 堆排序
  7. 二路归并排序
  8. 多路归并排序
  9. 计数排序
  10. 桶排序
  11. 基数排序

![sort信息](C:\Users\Administrator\Desktop\算法\截图\sort信息.png)

> 算法稳定性：假设在数列中存在 a[i] = a[j], 若在排列之前，a[i] = a[j] 前面；并且排序之后，a[i] 仍然在 a[j] 前面。则这个排序算法是稳定的



> + 数据结构
>
> 1. 数组和链表
>
> 数组元素在内存中都是连续的。可以很方便的根据下标查找数据，但插入数据麻烦
>
> 链表元素可存放在内存的任何地方，每个元素都存储了下一个元素的地址。可以很方便的插入数据，但查找数据只能顺序。
>
> 链表又分为单链表、双向链表、循环链表
>
> |      | 数组 | 链表 |
> | ---- | ---- | ---- |
> | 读取 | O(1) | O(n) |
> | 插入 | O(n) | O(1) |
>
> 
>
> 2. 哈希表(散列表)
>
> 根据关键码值而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度





## 二分算法

+ 特点：

  1.  比较次数少，查找速度快，平均性能好

  2. 只适用于从有序队列中进行查找

  3. 二分查找发的时间复杂度
     $$
     O(\log_2N)
     $$

  4. 适用于不经常变动但却查找频繁的有序列表

​	

+ 步骤：

  1. 首先确定整个查找区间的中间位置mid = ( left + right ) / 2

  2. 用待查关键字值与中间位置的关键字值进行比较

     若相等，则查找成功

     若大于，则在后(右) 半个区域继续进行折半查找

     若小于，则在前(左) 半个区域继续进行折半查找

  3. 对确定的缩小区域再按折半公式，重复上述步骤

  

```go
// go实现

// 递归实现
func Binary_search_main(arr *[]int, start int, end int, findVal int) {
	middle := (start + end) / 2
	if findVal == (*arr)[middle] {
		fmt.Println("目标下标 ", middle)
	} else if findVal > (*arr)[middle] {
		start = middle + 1
		Binary_search_main(arr, start, end, findVal)
	} else {
		end = middle - 1
		Binary_search_main(arr, start, end, findVal)
	}
}

// 普通实现
func Binary_search(num int) {
	fmt.Println("num = ", num)
	var arr [300]int
	for i := 0; i < len(arr); i++ {
		arr[i] = i + 1
	}
	// for index, value := range arr {
	// 	fmt.Printf("arr[%v] = %v\n", index, value)
	// }
	var start int = 0
	var end int = len(arr) - 1
	var middle int = (start + end) / 2
	fmt.Printf("start = %v , end = %v , middle = %v \n", start, end, middle)
	for {
		if num == arr[middle] {
			fmt.Println("middle = ", middle)
			fmt.Println("num = ", num)
			break
		} else if num > arr[middle] {
			middle = (middle + end) / 2
		} else {
			middle = (middle + start) / 2
		}
	}
}

func main() {
	Binary_search(4)

	arr := []int{2, 3, 7, 8, 12, 56, 75}
	test.Binary_search_main(&arr, 0, len(arr)-1, 7)
}
```



```java
// java实现

public class BinarySearch { 
        /** 
        * 二分查找算法 
        * 
        * @param srcArray 有序数组 
        * @param key 查找元素 
        * @return key的数组下标，没找到返回-1 
        */  
        public static void main(String[] args) { 
            int srcArray[] = {3,5,11,17,21,23,28,30,32,50,64,78,81,95,101};   
            System.out.println(binSearch(srcArray, 0, srcArray.length - 1, 81));  
        } 

        // 二分查找递归实现   
        public static int binSearch(int srcArray[], int start, int end, int key) {   
            int mid = (end - start) / 2 + start;   
            if (srcArray[mid] == key) {   
                return mid;   
            }   
            if (start >= end) {   
                return -1;   
            } else if (key > srcArray[mid]) {   
                return binSearch(srcArray, mid + 1, end, key);   
            } else if (key < srcArray[mid]) {   
                return binSearch(srcArray, start, mid - 1, key);   
            }   
            return -1;   
        } 

        // 二分查找普通循环实现   
        public static int binSearch(int srcArray[], int key) {   
            int mid = srcArray.length / 2;   
            if (key == srcArray[mid]) {   
                return mid;   
            }   

            int start = 0;   
            int end = srcArray.length - 1;   
            while (start <= end) {   
                mid = (end - start) / 2 + start;   
                if (key < srcArray[mid]) {   
                   end = mid - 1;   
                } else if (key > srcArray[mid]) {   
                    start = mid + 1;   
                } else {   
                    return mid;   
                }   
            }   
            return -1;   
        } 
    }
```







## 选择排序

```go
func main() {
    // 注：切片是引用类型，函数内部对slice的修改会影响到原数据；数组是值类型，传入的原数据的副本
	// var slice []int = []int{1, 54, 18, 2, 93}
	var array [5]int = [5]int{1, 54, 18, 2, 93}
	SelectSort(array)
	for k, v := range array {
		fmt.Printf("array[%v] = %v \n", k, v)
	}
}

func SelectSort(slice [5]int) {
	for i := 0; i < len(slice); i++ {
		for j := i+1; j < len(slice); j++ {
			if slice[i] > slice[j] {
				slice[i], slice[j] = slice[j], slice[i]
			}
		}
	}

	for k, v := range slice {
		fmt.Printf("slice[%v] = %v \n", k, v)
	}
}
```





> 递归函数
>
> 函数直接或间接调用函数本身，则该函数称为递归函数。递归函数必须有结束条件，不然就会陷入死循环
>
> 每个递归函数都有两部分：基线条件 和 递归条件
>
> 递归条件指的是函数调用自己，而基线条件则指的是函数不在调用自己，从而避免形成无限循环





## 快速排序

步骤

1. 选定中心轴
2. 将大于中心轴的数字放在中心轴的右边
3. 将小于中心轴的数组放在中心轴的左边
4. 分布对左右子序列重复前三步操作
